#####################################################################################################
# “PrOMMiS” was produced under the DOE Process Optimization and Modeling for Minerals Sustainability
# (“PrOMMiS”) initiative, and is copyright (c) 2023-2025 by the software owners: The Regents of the
# University of California, through Lawrence Berkeley National Laboratory, et al. All rights reserved.
# Please see the files COPYRIGHT.md and LICENSE.md for full copyright and license information.
#####################################################################################################
r"""
IDAES REE Feed Roaster Unit Model
==================================

This model represents a roaster/calcination unit for Rare Earth Element (REE) feedstock, which includes rare earth minerals, gangue/impurity minerals, moisture, and combustible organic materials containing C, H, O, N, and S elements.
This model can be used for both steady-state and dynamic simulations. Since the reaction kinetics are considered, the reactor volume and voidage of the reactor bed have to be specified and solid material holdup will be calculated even for a steady-state simulation.

Reactions
---------

The reactions of impurities involved are listed below:

1. Kaolinite calcination:
   
   .. ce::
      Al2O3 \cdot 2SiO2 \cdot 2H2O -> Al2O3 + 2 SiO2 + 2 H2O (g)

   Typically occurs above 400°C. Complete conversion is assumed for this reaction.

2. Limestone calcination:

   .. ce::
      CaCO3 -> CaO + CO2 (g)

   Typically occurs above 850°C; conversion is a determined by kinetics from a reference listed below:
   Carrillo Garcia, A. (2019). Thermal Decomposition of a Rare Earth Ore [Ph.D. thesis, Polytechnique Montréal]. PolyPublie. https://publications.polymtl.ca/4147/

3. Pyrite combustion:

   .. ce::
      FeS2 + 2.75 O2 -> 0.5 Fe2O3 + 2 SO2 (g)

   Typically occurs above 600°C. Complete conversion is assumed.

Combustion of organic elements is modeled as follows:

- :ce:`C + O2 -> CO2`
- :ce:`H + 0.25 O2 -> 0.5 H2O`
- :ce:`O -> 0.5 O2`
- :ce:`N -> 0.5 N2`
- :ce:`S + O2 -> SO2`

The reactions of insoluable rare earth mineral represented by RE2X to dissovable rare earth oxide RE2O3 and inert rare earth mineral (never leachable) Ree2X are through two parallel competing reactions.

   .. ce::
      RE2X  -> y1 RE2O3 + (1-y1) Ree2X

   .. ce::
      RE2X  -> y2 RE2O3 + (1-y2) Ree2X

   where RE represent an element including Sc, Y, La, Ce, Pr, Nd, Sm, Gd, Dy.
   The first reaction has a lower activation energy and a higher oxide yield while the second reaction has a higher activation energy and a lower oxide yield.
   This reaction mechanism tends to predict low conversion to dissovable oxide at too low or too high reaction temperatures.


Physical Changes
----------------

Moisture in the feed stream is vaporized.

Solid Composition
----------------------

A property package named ReeFeedParameters should be used to represent the solid feed material.
Impurity minerals are assumed to be a mixture of :ce:`SiO2`, :ce:`Al2O3`, kaolinite, :ce:`CaCO3`, :ce:`CaO`, pyrite (:ce:`FeS2`), and :ce:`Fe2O3`.
The solid feed material also contains moisture and organic material including :ce:`C`, :ce:`H`, :ce:`O`, :ce:`N`, :ce:`S` elements. The composition of the organic material is specified by the user.
The insoluable rare earth mineral is represented as RE2X in the ReeFeedParameters property package where RE stands for a rare earth element.
The dissovable rare earth mineral is represented as RE2O3 in the ReeFeedParameters property package where RE stands for a rare earth element.
After roasting, the solid product stream does not contain moisture and organic contents. A property package named ReeRoastParameters is used to represent the solid product.

Heat Source
-----------

The heat to the reactor can be provided either by external heating as a user input or by the combustion of a fossil fuel with air to form a hot :ce:`O2`-containing flue gas. The gas inlet stream is an :ce:`O2`-containing hot flue gas.
Due to the combustible organic contents in the solid feed stream, heat is usually generated by the combustion of the organic material. However, hot gas is still required to start the combustion.

Streams
-------

- **Gas Inlet Stream**: :ce:`O2`-containing hot flue gas fed to the reactor. It must contain at least :ce:`O2`, :ce:`N2`, :ce:`H2O`, :ce:`CO2`, and :ce:`SO2`. IDAES' generic ideal gas property package can be used for the gas stream.
- **Gas Outlet Stream**: Gas product leaving the reactor. The same gas property package as that for the gas inlet stream shold be used.
- **Solid Inlet Stream**: Solid REE-containling material fed to the reactor. A property package of ReeFeedParameters should be used.
- **Solid Outlet Stream**: Solid product leaving the reactor without moisture and organic contents. A property package of ReeRoastParameters should be used.
- **Leach Solid Outlet Stream**: Solid product leaving the reactor with species consistent with the leach solids property package CoalRefuseParameters. This stream can be linked to the subsequent leaching unit.


Thermal Properties
------------------

The standard heats of formation and heat capacities of solid components involved are defined as parameters in this model. The default values of those parameters are obtained from two sources as listed below:

1. NIST Chemistry WebBook
2. Wagman, D.D., W.H. Evans, V.B. Parker, R.H.Schumm, I. Halow, S.M. Bailey, K.L. Churney,
   R.L. Nuttall, "The NBS tables of chemical thermodynamic properties-Selected values for
   inorganic and C1 and C2 organic substances in SI units," Journal of Physical and Chemical
   Reference Data, 11(2), 1982

The NIST WebBook data are used for the properties of :ce:`Al2O3`, :ce:`SiO2`, :ce:`CaO`, :ce:`Fe2O3`, and `pyrite`. Note that the heat capacity model is simplified as a linear function of temperature.
The data of Wagman et al are used for the properties of :ce:`CaCO3` and `kaolinite`.
The gas phase properties are calculated based on user configured property package.
The heat capacity of organic part of the feed is usually a function of temperature and elemental composition of C, H, O, N, and S elements according to Merrick (1983).
For simplicity, a constant heat capacity of 1260 J/kg-K in the range reported by Merrick is used in this model. The standard enthalpy of formation of the organic material is assumed to be zero. In other words, individual elements are treated as pure species, which may slightly overpredict the higher heating value of the organic material.

Assumptions
-----------

- No kinetics or mass transfer is considered for the Kaolinite calcination and pyrite combustion. Complete conversions are assumed.
- Reaction rate for :ce:`CaCO3` calcination is based on kinetics reported by Carrillo Garcia (2019). The rate is a function of conversion. It is assumed that the conversion of :ce:`CaCO3` in the feed stream is zero.
- Reaction rates for the conversion of insoluble REE mineral to dissolvable mineral for each element is modeled by two competing reactions with two different activation energies and yield fractions.
- The carryover of fine particles by the gas stream is ignored. The user should add a splitter model for the solid product stream to account for the solid material loss due to the carryover.
- Rare earth minerals, being in ppm level, are ignored in energy balance. The property packages assume zero enthalpy and heat capacity for them.
- If the product temperature is specified as a user input, the heat duty will be calculated. If the heat duty is given, the product temperature will be calculated. Note that due to the contents of combustible organic elements, the overall effect of the reactions is very likely exothermic even though calcination reactions are endothermic.
- Temperatures of solid and gas products are assumed to be the same.

"""

# Import Pyomo libraries
from pyomo.common.config import Bool, ConfigBlock, ConfigValue

# Additional import for the unit operation
from pyomo.environ import Param, Var, exp, sqrt, Constraint
from pyomo.environ import units as pyunits

import idaes.core.util.scaling as iscale
import idaes.logger as idaeslog

# Import IDAES cores
from idaes.core import UnitModelBlockData, declare_process_block_class, useDefault
from idaes.core.solvers import get_solver
from idaes.core.util.config import DefaultBool, is_physical_parameter_block
from idaes.core.util.constants import Constants as const

from pyomo.dae import DerivativeVar

__author__ = "Jinliang Ma"
__version__ = "1.0.0"


# ----------------------------------------------------------------------------------------------------------
@declare_process_block_class("REEFeedRoaster")
class REEFeedRoasterData(UnitModelBlockData):
    """
    Simple 0D roaster model with mass and energy balance only
    """

    CONFIG = ConfigBlock()
    CONFIG.declare(
        "dynamic",
        ConfigValue(
            domain=DefaultBool,
            default=useDefault,
            description="Dynamic model flag",
            doc="""Indicates whether this model will be dynamic or not,
**default** = useDefault.
**Valid values:** {
**useDefault** - get flag from parent (default = False),
**True** - set as dynamic model,
**False** - set as a steady-state model.}""",
        ),
    )
    CONFIG.declare(
        "has_holdup",
        ConfigValue(
            default=True,
            domain=Bool,
            description="Holdup construction flag",
            doc="""Indicates whether holdup terms should be constructed or not.
Must be True if dynamic = True,
**default** - False.
**Valid values:** {
**True** - construct holdup terms,
**False** - do not construct holdup terms}""",
        ),
    )
    CONFIG.declare(
        "gas_property_package",
        ConfigValue(
            default=useDefault,
            domain=is_physical_parameter_block,
            description="Property package to use for control volume",
            doc="""Property parameter object used to define property calculations,
**default** - useDefault.
**Valid values:** {
**useDefault** - use default package from parent model or flowsheet,
**PhysicalParameterObject** - a PhysicalParameterBlock object.}""",
        ),
    )
    CONFIG.declare(
        "gas_property_package_args",
        ConfigBlock(
            implicit=True,
            description="Arguments to use for constructing property packages",
            doc="""A ConfigBlock with arguments to be passed to a property block(s)
and used when constructing these,
**default** - None.
**Valid values:** {
see property package for documentation.}""",
        ),
    )
    CONFIG.declare(
        "solid_feed_property_package",
        ConfigValue(
            default=useDefault,
            domain=is_physical_parameter_block,
            description="Property package to use for control volume",
            doc="""Property parameter object used to define property calculations,
**default** - useDefault.
**Valid values:** {
**useDefault** - use default package from parent model or flowsheet,
**PhysicalParameterObject** - a PhysicalParameterBlock object.}""",
        ),
    )
    CONFIG.declare(
        "solid_feed_property_package_args",
        ConfigBlock(
            implicit=True,
            description="Arguments to use for constructing property packages",
            doc="""A ConfigBlock with arguments to be passed to a property block(s)
and used when constructing these,
**default** - None.
**Valid values:** {
see property package for documentation.}""",
        ),
    )
    CONFIG.declare(
        "solid_product_property_package",
        ConfigValue(
            default=useDefault,
            domain=is_physical_parameter_block,
            description="Property package to use for control volume",
            doc="""Property parameter object used to define property calculations,
**default** - useDefault.
**Valid values:** {
**useDefault** - use default package from parent model or flowsheet,
**PhysicalParameterObject** - a PhysicalParameterBlock object.}""",
        ),
    )
    CONFIG.declare(
        "solid_product_property_package_args",
        ConfigBlock(
            implicit=True,
            description="Arguments to use for constructing property packages",
            doc="""A ConfigBlock with arguments to be passed to a property block(s)
and used when constructing these,
**default** - None.
**Valid values:** {
see property package for documentation.}""",
        ),
    )
    CONFIG.declare(
        "leach_solids_property_package",
        ConfigValue(
            default=useDefault,
            domain=is_physical_parameter_block,
            description="Property package to use for control volume",
            doc="""Property parameter object used to define property calculations,
**default** - useDefault.
**Valid values:** {
**useDefault** - use default package from parent model or flowsheet,
**PhysicalParameterObject** - a PhysicalParameterBlock object.}""",
        ),
    )
    CONFIG.declare(
        "leach_solids_property_package_args",
        ConfigBlock(
            implicit=True,
            description="Arguments to use for constructing property packages",
            doc="""A ConfigBlock with arguments to be passed to a property block(s)
and used when constructing these,
**default** - None.
**Valid values:** {
see property package for documentation.}""",
        ),
    )
    CONFIG.declare(
        "has_heat_transfer",
        ConfigValue(
            default=False,
            domain=Bool,
            description="Heat transfer term construction flag",
            doc="""Indicates whether terms for heat transfer should be constructed,
**default** - False.
**Valid values:** {
**True** - include heat transfer terms,
**False** - exclude heat transfer terms.}""",
        ),
    )
    CONFIG.declare(
        "has_pressure_change",
        ConfigValue(
            default=False,
            domain=Bool,
            description="Pressure change term construction flag",
            doc="""Indicates whether terms for pressure change should be
constructed,
**default** - False.
**Valid values:** {
**True** - include pressure change terms,
**False** - exclude pressure change terms.}""",
        ),
    )

    def build(self):
        # Call TranslatorData build to setup dynamics
        super(REEFeedRoasterData, self).build()

        # Build inlet and outlet state blocks
        # gas phase inlet stream
        self.gas_in = self.config.gas_property_package.build_state_block(
            self.flowsheet().time,
            defined_state=True,
            **self.config.gas_property_package_args
        )
        # gas phase outlet stream
        self.gas_out = self.config.gas_property_package.build_state_block(
            self.flowsheet().time, **self.config.gas_property_package_args
        )
        # solid phase inlet stream

        self.solid_in = self.config.solid_feed_property_package.build_state_block(
            self.flowsheet().time,
            defined_state=True,
            **self.config.solid_feed_property_package_args
        )

        # solid phase product stream
        self.solid_out = self.config.solid_product_property_package.build_state_block(
            self.flowsheet().time, **self.config.solid_product_property_package_args
        )

        # leach solid product stream
        self.leach_solid_out = (
            self.config.leach_solids_property_package.build_state_block(
                self.flowsheet().time, **self.config.leach_solids_property_package_args
            )
        )

        self.add_port("gas_inlet", self.gas_in)
        self.add_port("gas_outlet", self.gas_out)
        self.add_port("solid_inlet", self.solid_in)
        self.add_port("solid_outlet", self.solid_out)
        self.add_port("leach_solid_outlet", self.leach_solid_out)

        # Add Geometry
        # This model always has a volume for reaction rate calculation
        # In other words, there is always a material holdup
        # Currently the gas phase material and energy holdup are ignored even for dynamic model
        # The energy holdup is needed only for dynamic cases

        self.volume = Var(initialize=1, units=pyunits.m**3, doc="volume of the reactor")
        self.volume.fix()

        self.voidage = Var(
            initialize=0.4,
            doc="Void fraction of the reactor bed. The fraction occupied by the gas phase",
        )
        self.voidage.fix()

        @self.Expression(doc="Volume of solid phase")
        def volume_solid(b):
            return b.volume * (1 - b.voidage)

        # Add heat duty
        if self.config.has_heat_transfer is True:
            self.heat_duty = Var(
                self.flowsheet().time,
                initialize=0,
                units=pyunits.W,
                doc="heat duty added to the reactor",
            )

        if self.config.has_pressure_change is True:
            self.deltaP = Var(
                self.flowsheet().time,
                initialize=0,
                units=pyunits.Pa,
                doc="pressure drop from inlet to outlet",
            )

        self.Ree_list = ["Sc", "Y", "La", "Ce", "Pr", "Nd", "Sm", "Gd", "Dy"]
        self.Ree_Ins_lookup = {
            "Sc": "Sc2X",
            "Y": "Y2X",
            "La": "La2X",
            "Ce": "Ce2X",
            "Pr": "Pr2X",
            "Nd": "Nd2X",
            "Sm": "Sm2X",
            "Gd": "Gd2X",
            "Dy": "Dy2X",
        }

        # Construct performance equations
        self._make_params()
        self._make_vars()
        self._make_mass_balance()
        self._make_energy_balance()
        self._make_momentum_balance()

    def _make_params(self):
        self.A_CaCO3 = Param(
            initialize=exp(23.5),
            mutable=True,
            units=1 / pyunits.s,
            doc="Pre-exponential factor for CaCO3 decomposition",
        )

        # Kinetic parameter and model format based on Adrian Carrillo Garcia,
        # "Thermal Decomposition of a Rare Earth Ore", PhD Dissertation, Polytechnique Montréal, 2019
        self.E_CaCO3 = Param(
            initialize=2.094e5,
            mutable=True,
            units=pyunits.J / pyunits.mol,
            doc="Activation energy for CaCO3 decomposition",
        )

        self.A_REE1 = Param(
            self.Ree_list,
            initialize=23.7,
            mutable=True,
            units=1 / pyunits.s,
            doc="Pre-exponential factor for the first REE roasting reaction",
        )

        self.A_REE2 = Param(
            self.Ree_list,
            initialize=3.6e7,
            mutable=True,
            units=1 / pyunits.s,
            doc="Pre-exponential factor for the 2nd REE roasting reaction",
        )

        self.E_REE1 = Param(
            self.Ree_list,
            initialize=75980.0,
            mutable=True,
            units=pyunits.J / pyunits.mol,
            doc="Activation energy for the 1st REE roasting reaction",
        )

        self.E_REE2 = Param(
            self.Ree_list,
            initialize=203339.3,
            mutable=True,
            units=pyunits.J / pyunits.mol,
            doc="Activation energy for the 2nd REE roasting reaction",
        )

        self.y_REE1 = Param(
            self.Ree_list,
            initialize=0.375 * 2,
            mutable=True,
            doc="Fraction of dissolvable REE product after roasting for the 1st reaction",
        )

        self.y_REE2 = Param(
            self.Ree_list,
            initialize=9.31e-5 * 2,
            mutable=True,
            doc="Fraction of dissolvable REE product after roasting for the 2nd reaction",
        )

    def _make_vars(self):
        """This section declares variables within this model."""
        self.solid_material_holdup = Var(
            self.flowsheet().time,
            self.config.solid_product_property_package.component_list,
            initialize=1.0,
            units=pyunits.mol,
            doc="Solid species mole holdup",
        )

        if self.config.dynamic:
            self.solid_energy_holdup = Var(
                self.flowsheet().time,
                initialize=1.0,
                units=pyunits.J,
                doc="Solid energy holdup",
            )

            self.solid_material_accumulation = DerivativeVar(
                self.solid_material_holdup,
                wrt=self.flowsheet().config.time,
                units=pyunits.mol / pyunits.s,
                doc="Accumulation of solid material",
            )

            self.solid_energy_accumulation = DerivativeVar(
                self.solid_energy_holdup,
                wrt=self.flowsheet().config.time,
                units=pyunits.W,
                doc="Solid energy accumulation",
            )

        self.rate_CaCO3 = Var(
            self.flowsheet().config.time,
            initialize=1.0,
            units=pyunits.mol / pyunits.s,
            doc="Rate of CaCO3 decomposition, Always positive",
        )

        self.rate_REE1 = Var(
            self.flowsheet().config.time,
            self.Ree_list,
            initialize=1.0,
            units=pyunits.mol / pyunits.s,
            doc="Rate of 1st REE roasting reaction in term of mole of reactant reacted, Always positive",
        )

        self.rate_REE2 = Var(
            self.flowsheet().config.time,
            self.Ree_list,
            initialize=1.0,
            units=pyunits.mol / pyunits.s,
            doc="Rate of 2nd REE roasting reaction in term of mole of reactant reacted, Always positive",
        )

    def _make_mass_balance(self):
        """This section contains equations for mass balance within the reactor model."""

        @self.Expression(
            self.flowsheet().config.time,
            doc="Mole fraction of original CaCO3 between CaCO3 and CaO in feed stream",
        )
        def mole_fraction_of_ca_as_caco3_in_feed(b, t):
            return (
                b.solid_in[t].mass_frac_comp["CaCO3"]
                / b.config.solid_feed_property_package.mw_comp["CaCO3"]
                / (
                    b.solid_in[t].mass_frac_comp["CaCO3"]
                    / b.config.solid_feed_property_package.mw_comp["CaCO3"]
                    + b.solid_in[t].mass_frac_comp["CaO"]
                    / b.config.solid_feed_property_package.mw_comp["CaO"]
                )
            )

        # Holdup calculations
        @self.Constraint(
            self.flowsheet().config.time,
            self.config.solid_product_property_package.component_list,
            doc="Solid material holdup",
        )
        def solid_material_holdup_eqn(b, t, i):
            return (
                b.solid_material_holdup[t, i]
                == b.volume_solid
                * self.config.solid_product_property_package.dens_mass
                * b.solid_out[t].mass_frac_comp[i]
                / self.config.solid_product_property_package.mw_comp[i]
            )

        if self.config.dynamic:

            @self.Constraint(
                self.flowsheet().config.time,
                doc="Solid internal energy holdup",
            )
            def solid_energy_holdup_eqn(b, t):
                return (
                    b.solid_energy_holdup[t]
                    == b.volume_solid
                    * self.config.solid_product_property_package.dens_mass
                    * b.solid_out[t].enth_mass
                )

        @self.Constraint(
            self.flowsheet().config.time,
            doc="CaCO3 decomposition rate",
        )
        def rate_CaCO3_eqn(b, t):
            return b.rate_CaCO3[t] == 2 * sqrt(
                b.solid_material_holdup[t, "CaCO3"]
                *
                # b.mole_fraction_of_ca_as_caco3_in_feed[t]*
                (
                    b.solid_material_holdup[t, "CaCO3"]
                    + b.solid_material_holdup[t, "CaO"]
                )
            ) * b.A_CaCO3 * exp(
                -b.E_CaCO3 / const.gas_constant / b.solid_out[t].temperature
            )

        @self.Constraint(
            self.flowsheet().config.time,
            self.Ree_list,
            doc="Rate of the 1st roasting reaction",
        )
        def rate_REE1_eqn(b, t, i):
            j = b.Ree_Ins_lookup[i]
            return b.rate_REE1[t, i] == b.solid_material_holdup[t, j] * b.A_REE1[
                i
            ] * exp(-b.E_REE1[i] / const.gas_constant / b.solid_out[t].temperature)

        @self.Constraint(
            self.flowsheet().config.time,
            self.Ree_list,
            doc="Rate of the 2nd roasting reaction",
        )
        def rate_REE2_eqn(b, t, i):
            j = b.Ree_Ins_lookup[i]
            return b.rate_REE2[t, i] == b.solid_material_holdup[t, j] * b.A_REE2[
                i
            ] * exp(-b.E_REE2[i] / const.gas_constant / b.solid_out[t].temperature)

        # solid phase mass balance equation
        @self.Constraint(
            self.flowsheet().config.time,
            self.config.solid_product_property_package.component_list,
            doc="Species material balance for the solid phase",
        )
        def solid_mass_balance_eqn(b, t, i):
            if self.config.dynamic:
                accumulation = b.solid_material_accumulation[t, i]
            else:
                accumulation = 0
            if i == "Al2O3":
                # Kaolinite -> Al2O3 + 2 SiO2 + 2 H2O (g)
                return (
                    accumulation
                    == b.solid_in[t].flow_mol_comp[i]
                    - b.solid_out[t].flow_mol_comp[i]
                    + b.solid_in[t].flow_mol_comp["Kaolinite"]
                )
            elif i == "SiO2":
                # Kaolinite -> Al2O3 + 2 SiO2 + 2 H2O (g)
                return (
                    accumulation
                    == b.solid_in[t].flow_mol_comp[i]
                    - b.solid_out[t].flow_mol_comp[i]
                    + b.solid_in[t].flow_mol_comp["Kaolinite"] * 2
                )
            elif i == "CaCO3":
                # CaCO3 -> CaO + CO2 (g)
                return (
                    accumulation
                    == b.solid_in[t].flow_mol_comp[i]
                    - b.solid_out[t].flow_mol_comp[i]
                    - b.rate_CaCO3[t]
                )
            elif i == "CaO":
                # CaCO3 -> CaO + CO2 (g)
                return (
                    accumulation
                    == b.solid_in[t].flow_mol_comp[i]
                    - b.solid_out[t].flow_mol_comp[i]
                    + b.rate_CaCO3[t]
                )
            elif i == "Fe2O3":
                # FeS2 + 2.75O2 (g) -> 0.5Fe2O3 + 2SO2 (g)
                return (
                    accumulation
                    == b.solid_in[t].flow_mol_comp[i]
                    - b.solid_out[t].flow_mol_comp[i]
                    + 0.5 * b.solid_in[t].flow_mol_comp["FeS2"]
                )
            elif i == "Ree2X":
                # RE2X -> yRE2O3 + (1-y)Ree2X with O2 reactant ignored
                return accumulation == b.solid_in[t].flow_mol_comp[i] - b.solid_out[
                    t
                ].flow_mol_comp[i] + sum(
                    (1 - b.y_REE1[j]) * b.rate_REE1[t, j]
                    + (1 - b.y_REE2[j]) * b.rate_REE2[t, j]
                    for j in b.Ree_list
                )
            elif i == "Sc2X":
                return (
                    accumulation
                    == b.solid_in[t].flow_mol_comp[i]
                    - b.solid_out[t].flow_mol_comp[i]
                    - b.rate_REE1[t, "Sc"]
                    - b.rate_REE2[t, "Sc"]
                )
            elif i == "Sc2O3":
                return (
                    accumulation
                    == b.solid_in[t].flow_mol_comp[i]
                    - b.solid_out[t].flow_mol_comp[i]
                    + b.y_REE1["Sc"] * b.rate_REE1[t, "Sc"]
                    + b.y_REE2["Sc"] * b.rate_REE2[t, "Sc"]
                )
            elif i == "Y2X":
                return (
                    accumulation
                    == b.solid_in[t].flow_mol_comp[i]
                    - b.solid_out[t].flow_mol_comp[i]
                    - b.rate_REE1[t, "Y"]
                    - b.rate_REE2[t, "Y"]
                )
            elif i == "Y2O3":
                return (
                    accumulation
                    == b.solid_in[t].flow_mol_comp[i]
                    - b.solid_out[t].flow_mol_comp[i]
                    + b.y_REE1["Y"] * b.rate_REE1[t, "Y"]
                    + b.y_REE2["Y"] * b.rate_REE2[t, "Y"]
                )
            elif i == "La2X":
                return (
                    accumulation
                    == b.solid_in[t].flow_mol_comp[i]
                    - b.solid_out[t].flow_mol_comp[i]
                    - b.rate_REE1[t, "La"]
                    - b.rate_REE2[t, "La"]
                )
            elif i == "La2O3":
                return (
                    accumulation
                    == b.solid_in[t].flow_mol_comp[i]
                    - b.solid_out[t].flow_mol_comp[i]
                    + b.y_REE1["La"] * b.rate_REE1[t, "La"]
                    + b.y_REE2["La"] * b.rate_REE2[t, "La"]
                )
            elif i == "Ce2X":
                return (
                    accumulation
                    == b.solid_in[t].flow_mol_comp[i]
                    - b.solid_out[t].flow_mol_comp[i]
                    - b.rate_REE1[t, "Ce"]
                    - b.rate_REE2[t, "Ce"]
                )
            elif i == "Ce2O3":
                return (
                    accumulation
                    == b.solid_in[t].flow_mol_comp[i]
                    - b.solid_out[t].flow_mol_comp[i]
                    + b.y_REE1["Ce"] * b.rate_REE1[t, "Ce"]
                    + b.y_REE2["Ce"] * b.rate_REE2[t, "Ce"]
                )
            elif i == "Pr2X":
                return (
                    accumulation
                    == b.solid_in[t].flow_mol_comp[i]
                    - b.solid_out[t].flow_mol_comp[i]
                    - b.rate_REE1[t, "Pr"]
                    - b.rate_REE2[t, "Pr"]
                )
            elif i == "Pr2O3":
                return (
                    accumulation
                    == b.solid_in[t].flow_mol_comp[i]
                    - b.solid_out[t].flow_mol_comp[i]
                    + b.y_REE1["Pr"] * b.rate_REE1[t, "Pr"]
                    + b.y_REE2["Pr"] * b.rate_REE2[t, "Pr"]
                )
            elif i == "Nd2X":
                return (
                    accumulation
                    == b.solid_in[t].flow_mol_comp[i]
                    - b.solid_out[t].flow_mol_comp[i]
                    - b.rate_REE1[t, "Nd"]
                    - b.rate_REE2[t, "Nd"]
                )
            elif i == "Nd2O3":
                return (
                    accumulation
                    == b.solid_in[t].flow_mol_comp[i]
                    - b.solid_out[t].flow_mol_comp[i]
                    + b.y_REE1["Nd"] * b.rate_REE1[t, "Nd"]
                    + b.y_REE2["Nd"] * b.rate_REE2[t, "Nd"]
                )
            elif i == "Sm2X":
                return (
                    accumulation
                    == b.solid_in[t].flow_mol_comp[i]
                    - b.solid_out[t].flow_mol_comp[i]
                    - b.rate_REE1[t, "Sm"]
                    - b.rate_REE2[t, "Sm"]
                )
            elif i == "Sm2O3":
                return (
                    accumulation
                    == b.solid_in[t].flow_mol_comp[i]
                    - b.solid_out[t].flow_mol_comp[i]
                    + b.y_REE1["Sm"] * b.rate_REE1[t, "Sm"]
                    + b.y_REE2["Sm"] * b.rate_REE2[t, "Sm"]
                )
            elif i == "Gd2X":
                return (
                    accumulation
                    == b.solid_in[t].flow_mol_comp[i]
                    - b.solid_out[t].flow_mol_comp[i]
                    - b.rate_REE1[t, "Gd"]
                    - b.rate_REE2[t, "Gd"]
                )
            elif i == "Gd2O3":
                return (
                    accumulation
                    == b.solid_in[t].flow_mol_comp[i]
                    - b.solid_out[t].flow_mol_comp[i]
                    + b.y_REE1["Gd"] * b.rate_REE1[t, "Gd"]
                    + b.y_REE2["Gd"] * b.rate_REE2[t, "Gd"]
                )
            elif i == "Dy2X":
                return (
                    accumulation
                    == b.solid_in[t].flow_mol_comp[i]
                    - b.solid_out[t].flow_mol_comp[i]
                    - b.rate_REE1[t, "Dy"]
                    - b.rate_REE2[t, "Dy"]
                )
            elif i == "Dy2O3":
                return (
                    accumulation
                    == b.solid_in[t].flow_mol_comp[i]
                    - b.solid_out[t].flow_mol_comp[i]
                    + b.y_REE1["Dy"] * b.rate_REE1[t, "Dy"]
                    + b.y_REE2["Dy"] * b.rate_REE2[t, "Dy"]
                )
            else:
                return Constraint.Skip

        # the gas product should contain at least N2, O2, H2O, CO2, and SO2
        # assume no accumulation in the gas phase
        @self.Constraint(
            self.flowsheet().config.time,
            self.config.gas_property_package.component_list,
            doc="Gas phase species mass balance",
        )
        def gas_mass_balance_eqn(b, t, i):
            if i == "N2":
                return (
                    b.gas_out[t].flow_mol_comp[i]
                    == b.gas_in[t].flow_mol_comp[i]
                    + b.solid_in[t].flow_mol_comp["N"] / 2
                )
            elif i == "O2":
                return (
                    b.gas_out[t].flow_mol_comp[i]
                    == b.gas_in[t].flow_mol_comp[i]
                    + b.solid_in[t].flow_mol_comp["O"] / 2
                    - b.solid_in[t].flow_mol_comp["C"]
                    - b.solid_in[t].flow_mol_comp["S"]
                    - b.solid_in[t].flow_mol_comp["H"] / 4
                    - b.solid_in[t].flow_mol_comp["FeS2"] * 2.75
                )
            elif i == "H2O":
                return (
                    b.gas_out[t].flow_mol_comp[i]
                    == b.gas_in[t].flow_mol_comp[i]
                    + b.solid_in[t].flow_mol_comp["H"] / 2
                    + b.solid_in[t].flow_mol_comp["Kaolinite"] * 2
                    + b.solid_in[t].flow_mol_comp["H2O"]
                )
            elif i == "CO2":
                return (
                    b.gas_out[t].flow_mol_comp[i]
                    == b.gas_in[t].flow_mol_comp[i]
                    + b.solid_in[t].flow_mol_comp["C"]
                    + b.rate_CaCO3[t]
                )
            elif i == "SO2":
                return (
                    b.gas_out[t].flow_mol_comp[i]
                    == b.gas_in[t].flow_mol_comp[i]
                    + b.solid_in[t].flow_mol_comp["S"]
                    + b.solid_in[t].flow_mol_comp["FeS2"] * 2
                )
            else:
                return b.gas_out[t].flow_mol_comp[i] == b.gas_in[t].flow_mol_comp[i]

        # leach solid outlet stream, let the inert mass fraction calculated by sum = 1
        @self.Constraint(
            self.flowsheet().config.time,
            self.config.solid_product_property_package.component_list,
            doc="component flow of outlet solid stream",
        )
        def leach_solid_outlet_comp_eqn(b, t, i):
            if i in b.config.leach_solids_property_package.component_list:
                return (
                    b.leach_solid_out[t].mass_frac_comp[i]
                    == b.solid_out[t].mass_frac_comp[i]
                )
            else:
                return Constraint.Skip

        @self.Constraint(
            self.flowsheet().config.time,
            doc="Total mass flow of leach solid out stream",
        )
        def leach_solid_outlet_total_mass_flow_eqn(b, t):
            return (
                pyunits.convert(
                    b.leach_solid_out[t].flow_mass,
                    to_units=pyunits.kg / pyunits.s,
                )
                == b.solid_out[t].flow_mass
            )

    def _make_energy_balance(self):
        @self.Constraint(
            self.flowsheet().config.time,
            doc="Same gas and solid temperature constraint",
        )
        def outlet_temperature_eqn(b, t):
            return b.gas_out[t].temperature == b.solid_out[t].temperature

        # enthalpy in + heat in == enthalpy out
        @self.Constraint(
            self.flowsheet().config.time,
            doc="enthalpy balance equation for both phases",
        )
        def energy_balance_eqn(b, t):
            if self.config.has_heat_transfer is True:
                heat = b.heat_duty[t]
            else:
                heat = 0
            if self.config.dynamic:
                accumulation = b.solid_energy_accumulation[t]
            else:
                accumulation = 0
            return (
                accumulation
                == b.solid_in[t].enth_mass * b.solid_in[t].flow_mass
                + b.gas_in[t].enth_mol * b.gas_in[t].flow_mol
                - b.solid_out[t].enth_mass * b.solid_out[t].flow_mass
                - b.gas_out[t].enth_mol * b.gas_out[t].flow_mol
                + heat
            )

    def _make_momentum_balance(self):
        @self.Constraint(self.flowsheet().config.time, doc="momentum balance equation")
        def momentum_balance_eqn(b, t):
            if self.config.has_pressure_change is True:
                return b.gas_out[t].pressure == b.gas_in[t].pressure + b.deltaP[t]
            else:
                return b.gas_out[t].pressure == b.gas_in[t].pressure

    def set_initial_condition(self):
        if self.config.dynamic:
            t0 = self.flowsheet().time.first()
            self.solid_material_accumulation[:, :].value = 0
            self.solid_material_accumulation[t0, :].fix(0)
            self.solid_energy_accumulation[:].value = 0
            self.solid_energy_accumulation[t0].fix(0)

    def initialize_build(
        blk,
        state_args_gas_in=None,
        outlvl=idaeslog.NOTSET,
        solver=None,
        optarg=None,
    ):
        """
        Initialization routine.
        1.- initialize state blocks, using an initial guess for inlet
        gas inlet.
        2.- guess gas outlet component molar flowrates,
        Temperature, and Pressure. Initialize flue gas state block.
        3.- Then, solve complete model.

        Keyword Arguments:
            state_args_gas_in : a dict of arguments to be passed to the property
                           package(s) for the inlet gas state block to
                           provide an initial state for initialization
                           (see documentation of the specific property package)
                           (default = None).
            outlvl : sets output level of initialisation routine
            optarg : solver options dictionary object (default=None, use
                     default solver options)
            solver : str indicating which solver to use during
                     initialization (default = None, use default solver)

        Returns:
            None
        """
        init_log = idaeslog.getInitLogger(blk.name, outlvl, tag="unit")
        solve_log = idaeslog.getSolveLogger(blk.name, outlvl, tag="unit")

        # Create solver
        opt = get_solver(solver, optarg)

        # ---------------------------------------------------------------------
        # Initialize inlet gas property block
        blk.gas_in.initialize(
            outlvl=outlvl, optarg=optarg, solver=solver, state_args=state_args_gas_in
        )
        init_log.info_high("Initialization Step 1 Complete.")

        # initialize outlet gas property block
        blk.gas_out.initialize(
            outlvl=outlvl, optarg=optarg, solver=solver, state_args=state_args_gas_in
        )
        init_log.info_high("Initialization Step 2 Complete.")

        # set REE reaction rates to zero to estimate the initial guess of solid_out and holdup
        blk.rate_CaCO3.fix(0)
        blk.rate_REE1.fix(0)
        blk.rate_REE2.fix(0)
        for i in blk.config.leach_solids_property_package.component_list:
            blk.leach_solid_out[:].mass_frac_comp[i].fix(
                blk.config.leach_solids_property_package.mass_frac_comp_initial[i]
            )
        blk.leach_solid_out[:].mass_frac_comp["inerts"].unfix()
        blk.leach_solid_out[:].flow_mass.fix(blk.solid_in[0].flow_mass.value * 0.8)
        blk.rate_CaCO3_eqn.deactivate()
        blk.rate_REE1_eqn.deactivate()
        blk.rate_REE2_eqn.deactivate()
        blk.leach_solid_outlet_comp_eqn.deactivate()
        blk.leach_solid_outlet_total_mass_flow_eqn.deactivate()
        with idaeslog.solver_log(solve_log, idaeslog.DEBUG) as slc:
            res = opt.solve(blk, tee=slc.tee)
        init_log.info_high("Initialization Step 3 {}.".format(idaeslog.condition(res)))
        blk.rate_CaCO3.unfix()
        blk.rate_REE1.unfix()
        blk.rate_REE2.unfix()
        blk.leach_solid_out[:].mass_frac_comp[:].unfix()
        blk.leach_solid_out[:].flow_mass.unfix()
        blk.rate_CaCO3_eqn.activate()
        blk.rate_REE1_eqn.activate()
        blk.rate_REE2_eqn.activate()
        blk.leach_solid_outlet_comp_eqn.activate()
        blk.leach_solid_outlet_total_mass_flow_eqn.activate()
        with idaeslog.solver_log(solve_log, idaeslog.DEBUG) as slc:
            res = opt.solve(blk, tee=slc.tee)
        init_log.info("Initialization Complete.")

    def calculate_scaling_factors(self):
        super().calculate_scaling_factors()
        # sf_volume = iscale.get_scaling_factor(
        #        self.volume, default=1, warning=True)
        for i, c in self.rate_REE1_eqn.items():
            sf = iscale.get_scaling_factor(self.rate_REE1[i], default=1e5, warning=True)
            iscale.constraint_scaling_transform(c, sf, overwrite=False)

        for i, c in self.rate_REE2_eqn.items():
            sf = iscale.get_scaling_factor(self.rate_REE2[i], default=1e6, warning=True)
            iscale.constraint_scaling_transform(c, sf, overwrite=False)

        # set a default platen heat scaling factor
        if self.config.has_heat_transfer is True:
            for v in self.heat_duty.values():
                if iscale.get_scaling_factor(v, warning=True) is None:
                    iscale.set_scaling_factor(v, 1e-6)

        # set energy balance constraint scaling factor
        if self.config.has_heat_transfer is True:
            for t, c in self.energy_balance_eqn.items():
                sf = iscale.get_scaling_factor(
                    self.heat_duty[t], default=1e-6, warning=True
                )
                iscale.constraint_scaling_transform(c, sf, overwrite=False)

        for t, c in self.outlet_temperature_eqn.items():
            sf = iscale.get_scaling_factor(
                self.gas_out[t].temperature, default=1e-2, warning=True
            )
            iscale.constraint_scaling_transform(c, sf, overwrite=False)

        if self.config.dynamic:
            for t, c in self.solid_energy_holdup_eqn.items():
                sf = iscale.get_scaling_factor(
                    self.solid_energy_holdup[t], default=1e-8, warning=True
                )
                iscale.constraint_scaling_transform(c, sf, overwrite=False)
